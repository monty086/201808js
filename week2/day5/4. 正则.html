<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /*
    * 正则
    * 定义：正确的规则，它是专门用来处理字符串
    * RegExp
    * 正则分为修饰符和元字符【量词元字符，和特殊元字符】，其中两个斜杠中都属于元字符，斜杠后面是属于修饰符
    * */
    var reg = /^&/;

    /*
    * 如何创建一个正则
    * 1. 通过字面量的方式来创建
    * 2. 可以通过实例化的方式来创建，通过new关键字执行正则类，返回一个正则的实例；如果你创建的正则中有变量，我们必须通过实例化的方式来创建；通过实例化的方式创建，第一个参数是元字符，第二个参数是修饰符
    * */
    var reg = /\d/g;
    var a = '\d';
    var reg = new RegExp(a,'g')
    console.log(reg);

    /*
    * 正则上的方法
    * RegExp.prototype
    * test: 验证，校验创建的字符串，是否符合正确的规则，如果匹配的返回true，如果不匹配返回false；
    * exec：捕获=> 捕获之前会先拿正则匹配传入的字符串，如果匹配成功，返回字符串的详细信息，如果匹配不成功，返回null
    * */
    console.dir(RegExp.prototype);
    var reg = /\d/; // 表示数字的意思
    console.log(reg.test('6'));
    console.log(reg.exec('4a')); //["6", index: 0, input: "6a", groups: undefined]

    /*
    * 正则中常用的修饰符
    * i : ignoreCase=>忽略大小写
    * m ： multiline=> 多行匹配
    * g ： global => 全局匹配
    * */
    var reg = /\d/g;
    reg.test('1a2a3a4a');
    reg.lastIndex

    /*
    * 正则中常用的量词元字符
    * *：0个到多个
    * +：1个到多个
    * ？：0个或1个，【有或没有】
    * {n}: 匹配到n个
    * {n,}: 匹配n个到多个
    * {n,m}: 匹配n个到m个
    * */

    var reg = /\d{1,4}/;// 1990
    console.log(reg.exec('1990a2000b2008c'));

    /*
    * 正则中常用的特殊元字符
    * \d : 匹配0-9之间的任意一个数字
    * \D ： 除了0-9之间的任意字符
    * \w ： 匹配数字、字母、下划线，中的任意一个字符，[0-9a-zA-Z_]
    * \W : 除了数字，字母，下划线以外的任意字符
    * \s : 匹配一个空白字符 / /
    * \S ：除了空白字符以外的其他字符
    * \b ： 匹配一个边界 'box tag'
    * \B : 除了边界以外的其他字符
    * \n ： 匹配一个换行符
    *  . : 除了换行符以外的其他字符
    *  ^ : 匹配一个开始的符号
    *  $ : 匹配一个结束的符号
    * x|y ： x获y中的任意一个字符
    * [xy]: x或者y中的任意一个字符
    * [^xyz] : 非，除了xyz其他的任意字符
    * [a-z] : - 范围 : a到z中的任意一个字符 0-9 0-z
    * () : 分组捕获, 提高优先级、分组引用
    * (?:) : 取消分组捕获
    * (?=) : 正向预查
    * (?!) : 负向预查
    *
    * */

    /*
    * 普通元字符
    * 在正则当中，字面量方式创建的，两个斜杠中，除了特殊元字符和量词元字符以外的字符都叫做普通元字符
    *
    * */


</script>