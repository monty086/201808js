<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /*
    * 1.变量提升：
    * 作用域形成之后，代码加载之前，对带var和带function进行变量提升，带var只声明不定义，带function 声明加定义
    *
    * */
    /*fn()
    function fn(){}
    var fn = function(){};*/
    // es6 箭头函数
    let  fn = ()=>{}

    /*
    * var a = 1, b=2, c=3; // abc 都属于变量
    * var a = b = c= 1; // b 和c 是window上的一个属性
    * var a ; // window.a=undefined
    * a=> undefined
    * var a =1 ;b =2;c=3;
    * */

    /*
    * 特殊情况
    * 1.var f = function fn(){} //
    * 2.(function(){})()
    * 3. setTimeout(function fn(){},1000)
    * 4. return 右边不进行变量提升，下面不执行，但是会变量提升
    * 5. 判断中，以及块级作用域中 ，函数和变量一样只声明，条件成立后，第一时间给函数定义
    * */
    var n=10; // 2
    var obj1={
        n:1, // 2 3
        f:function () {
            this.n++; // obj1.n++ //1
            n=this.n++; // obj1.n++ // 2++
        }
    };
    obj1.f();
    console.log(n);//2
    console.log(obj1.n);//3
    /*
    * 栈内存：js执行的地方，存放基本数据类型
    * 堆内存：存放引用数据类型
    * 栈内存：关闭浏览器，函数执行完成，
    * 堆内存释放：将引用地址变量主动赋值null
    * */
    // function fn(){
    //     var a =1
    //     return function(){
    //      console.log(a++)
    //     }
    // }
    // var f = fn()
    // f()
    // f()
    // fn()()
    // fn()()

    /*
    * 闭包：保护机制，保护私有变量不受外界干扰
    *
    * */

    /*
    * this 执行主体
    * 1. 全局作用域
    * 2. 自运行函数
    * 3. 函数做参数
    * 4. 函数执行的时候，看有点，点前面是谁this就是谁
    * 5. 元素事件中的this是当前元素
    * 6. 构造函数this=》实例
    * 7. 通过call apply bind可以改变this
    * */

    /*
    * 单例模式：对象
    * 高级单例模式：自执行函数，返回值是一个对象
    * */

    /*
    * 低耦合高内聚：减少代码冗余，提高代码重复利用率
    * 工厂模式：函数
    * */

    /*
    * 构造函数：本质就是一个函数，但是它是通过new来执行，返回值是当前构造函数的实例，【构造函数也可以说是类，函数名就是类名，我一般建议类名首字母大写，为了和普通函数进行区分】
    *
    * */

    /*
    * 原型：prototype
    * 1. 所有的类【函数、类】都有一个属性叫做prototype，它是一个对象
    * 2. 所有的prototype都有一个属性叫做constructor，它指向当前类本身
    * 3. 所有的对象【实例、prototype、普通对象、函数、类】都有一个属性叫做__proto__，它指向当前所属类的原型
    * */

    /*
    * 实例的私有属性：在构造函数中定义的所有的给this添加的属性，都是实例的私有属性
    * 公有属性：类的原型上的所有的属性和方法，都是实例的公有属性和方法，实例.__proto__也可以找到它的公有属性和方法
    *
    * */

    /*
    * 在实例上找一个属性，先去实例的私有属性上找，如果没有的话，去【通过__proto__这个属性去】公有属性上找,如果公有属性还没有，再通过原型链向上级查找，直到找到基类Object的原型，如果原型上还没有这个属性返回undefined，这种查找机制就叫做原型链
    *
    * */

    /*
    * 函数的三种身份
    * 普通函数
    * 类 【内置类和自定义类】
    * 函数类的一个实例【对象】
    * */
    // function fn(){}

    /*
    * call : 1改变this2. 让函数执行 3. 第二个及以后的参数分别传参
    * apply： 第二个参数是一个数组，将值分别传给前面的函数
    * bind： 改this 不执行函数
    * */
</script>