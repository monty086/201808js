<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /*
    * css
    * transition
    * transform
    * animate
    *
    * js
    * 定时器
    * canvas
    * 帧动画
    *
    * flash
    *
    * 匀速直线运动的公式
    * time/duration*change+begin
    *
    * let const
    * 模板字符串
    * 箭头函数
    * 1. this
    * 2. arguments
    * 3. 没有构造函数
    * 解构赋值
    * 对象的解构赋值
    * let {name} = {name:'zf'}
    * let {name='china'} = {name:'zf'}
    * let {name:china} = {name:'zf'}  //china=>'zf'
    * 数组的解构赋值
    * let [,,a] = [1,2,3] // a=>1
    * let [,...a] = [1,2,3] // a=>[2,3]
    * 解构赋值，既可以拿到私有属性，也可以拿到公有属性
    * 函数的解构赋值
    * Promise
    * */
    /*let str = '123';
    str.__proto__.ab = 'zhufeng';
    let {ab} =str;
    console.log(ab);
    for(var key in str){
        // console.log(key);
    }*/
    var str = 'xyz';
    function fn(a,b,c){
        console.log(a, b, c);
    }
    fn(...str);
    function fn1(...arg){
        arg[0]='';
        console.log(arg);// ['','y','z']
    }
    fn1('x','y','z')
    function fn2([a,b,c]){
        console.log(a,b,c);// 'x' 'y' 'z'
    }
    fn2(['x','y','z'])
    function fn3({name:logo,add='street'}){
        console.log(logo,add);// logo=>'zf'  add=>'street'
    }
    fn3({name:'zf',age:'9'});
    fn3({name:'zf',age:'9',add:'subway'})



    // 回调函数
    function a(b){
        // console.log(this);
        // setTimeout(()=>{
        //     console.log(this);
            var obj = {};
            obj.b = b;
            console.log(obj.b([1,2,3]));//
        // })
    }
    let b=()=>{
        return this
    };


    a.call('box', b)
    // 普通函数中有this，this是看当前函数执行的时候前面是否有点，点前面是谁this就是谁，call方法可以强制改变this
    // 箭头函数中没有this，this是当前箭头函数所在作用域的上下文【环境】，跟在哪执行没有关系，跟在哪定义有关系


   /* function c(){
        return this
    }

    console.log(c);//
    console.log(c.call('box'));//this=>box
    console.log(c.bind('box'));// bound => c*/

   /*setTimeout(()=>{
       console.log(2);
   })*/

    // es6提供的一个类 Promise
    // Promise 中三个状态，一个是初始化成功pending 开始执行Promise中的异步代码，成功的函数=》resolve()
    // 失败的函数=》 reject ()

    // Promise 本身是同步执行的代码，它里面可以放异步的代码
    // Promise 它返回的一个实例，可以调用Promise类上的then方法

    // then方法： Promise类当中成功或者失败执行的方法，它只能通过实例进行调用

    // then方法执行，中有两个参数，分别是成功后执行的函数，和失败后执行的函数

    // 在Promise当中只能识别一种状态，只要遇到成功态或者失败态，就会结束，把第一次找到的状态，让相对应的函数执行，这个属于Promise机制



    function fn9(resolve,reject){
        console.log(1);
        console.log(typeof resolve);
        // resolve(3);
        reject(4)
    }
    let f = new Promise(fn9);
    /*let fnx = (resolve,reject)=>{
        resolve(3);
        reject();
    };
    var f = new Promise(fnx);*/

    /*f.then(()=>{
        console.log(3);
        return 3
    },()=>{
        //console.log(4);
    }).then((res)=>{
        console.log(res);
        return 8
    }).then((res)=>{
        console.log(res);
    })*/

    f.then((res)=>{
        console.log(res);//3
        /*return new Promise((resolve,reject)=>{
            reject(5)
        })*/
    }).catch((res)=>{
        console.log(res);
    })

    /*then(()=>{

    },(res)=>{
        console.log(res);
    })*/
</script>